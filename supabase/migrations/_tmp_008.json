{"value":"-- ============================================================\n-- Migration: 20260221_008_fix_double_cogs_and_fifo.sql\n-- Phase 1: إصلاح Double COGS وإعادة بناء FIFO Lots\n-- ============================================================\n-- المشكلة المكتشفة:\n-- كل فاتورة تُنشئ قيدَين منفصلَين:\n--   1) قيد \u0027invoice\u0027: يحتوي AR + Revenue + COGS(5000) + Inventory(credit)  ← مدمج قديم\n--   2) قيد \u0027invoice_cogs\u0027: يحتوي COGS(5100) + Inventory(credit)             ← صحيح\n-- النتيجة: المخزون يُخفَّض مرتَين، COGS مُضاعَفة\n-- الإصلاح: حذف أسطر COGS/Inventory من قيود النوع \u0027invoice\u0027 (الإبقاء على invoice_cogs فقط)\n-- ============================================================\n\nBEGIN;\n\n-- ─────────────────────────────────────────────\n-- 1. تسجيل الحالة قبل الإصلاح (للتدقيق)\n-- ─────────────────────────────────────────────\nDO $$\nDECLARE\n  v_affected_entries INTEGER;\n  v_affected_lines   INTEGER;\n  v_gl_inventory     NUMERIC;\nBEGIN\n  -- عد القيود المتأثرة\n  SELECT COUNT(DISTINCT je.id) INTO v_affected_entries\n  FROM journal_entries je\n  JOIN journal_entry_lines jel ON jel.journal_entry_id = je.id\n  JOIN chart_of_accounts coa ON coa.id = jel.account_id\n  WHERE je.reference_type = \u0027invoice\u0027\n    AND (\n      (jel.debit_amount \u003e 0  AND (coa.account_type = \u0027expense\u0027 OR coa.account_name ILIKE \u0027%مصروف%\u0027 OR coa.account_name ILIKE \u0027%تكلفة%\u0027))\n      OR\n      (jel.credit_amount \u003e 0 AND (coa.sub_type = \u0027inventory\u0027 OR coa.account_name ILIKE \u0027%مخزون%\u0027))\n    )\n    AND EXISTS (\n      SELECT 1 FROM journal_entries je2\n      WHERE je2.reference_id = je.reference_id\n        AND je2.reference_type = \u0027invoice_cogs\u0027\n    );\n\n  SELECT COUNT(jel.id) INTO v_affected_lines\n  FROM journal_entries je\n  JOIN journal_entry_lines jel ON jel.journal_entry_id = je.id\n  JOIN chart_of_accounts coa ON coa.id = jel.account_id\n  WHERE je.reference_type = \u0027invoice\u0027\n    AND (\n      (jel.debit_amount \u003e 0  AND (coa.account_type = \u0027expense\u0027 OR coa.account_name ILIKE \u0027%مصروف%\u0027 OR coa.account_name ILIKE \u0027%تكلفة%\u0027))\n      OR\n      (jel.credit_amount \u003e 0 AND (coa.sub_type = \u0027inventory\u0027 OR coa.account_name ILIKE \u0027%مخزون%\u0027))\n    )\n    AND EXISTS (\n      SELECT 1 FROM journal_entries je2\n      WHERE je2.reference_id = je.reference_id\n        AND je2.reference_type = \u0027invoice_cogs\u0027\n    );\n\n  RAISE NOTICE \u0027قبل الإصلاح: % قيد متأثر، % سطر للحذف\u0027, v_affected_entries, v_affected_lines;\nEND $$;\n\n-- ─────────────────────────────────────────────\n-- 2. حذف أسطر COGS/Inventory المكررة من قيود النوع \u0027invoice\u0027\n--    الشرط: يجب أن يكون للفاتورة ذاتها قيد \u0027invoice_cogs\u0027 مستقل\n-- ─────────────────────────────────────────────\nDELETE FROM journal_entry_lines\nWHERE id IN (\n  SELECT jel.id\n  FROM journal_entries je\n  JOIN journal_entry_lines jel ON jel.journal_entry_id = je.id\n  JOIN chart_of_accounts coa ON coa.id = jel.account_id\n  WHERE je.reference_type = \u0027invoice\u0027\n    AND (\n      -- سطر مدين على حساب مصروفات/تكلفة (COGS مكررة في قيد invoice)\n      (jel.debit_amount \u003e 0  AND (\n        coa.account_type = \u0027expense\u0027\n        OR coa.account_name ILIKE \u0027%مصروف%\u0027\n        OR coa.account_name ILIKE \u0027%تكلفة%\u0027\n        OR coa.sub_type    ILIKE \u0027%cogs%\u0027\n        OR coa.sub_type    ILIKE \u0027%cost_of_goods%\u0027\n      ))\n      OR\n      -- سطر دائن على حساب المخزون (Inventory credit مكررة في قيد invoice)\n      (jel.credit_amount \u003e 0 AND (\n        coa.sub_type      = \u0027inventory\u0027\n        OR coa.account_name ILIKE \u0027%مخزون%\u0027\n        OR coa.account_name ILIKE \u0027%inventory%\u0027\n      ))\n    )\n    -- فقط للفواتير التي لها قيد invoice_cogs منفصل\n    AND EXISTS (\n      SELECT 1\n      FROM journal_entries je2\n      WHERE je2.reference_id  = je.reference_id\n        AND je2.reference_type = \u0027invoice_cogs\u0027\n        AND je2.company_id     = je.company_id\n    )\n);\n\n-- ─────────────────────────────────────────────\n-- 3. التحقق من أن قيود \u0027invoice\u0027 متوازنة بعد الإصلاح\n-- ─────────────────────────────────────────────\nDO $$\nDECLARE\n  v_unbalanced INTEGER;\nBEGIN\n  SELECT COUNT(*) INTO v_unbalanced\n  FROM (\n    SELECT je.id, SUM(jel.debit_amount) AS total_debit, SUM(jel.credit_amount) AS total_credit\n    FROM journal_entries je\n    JOIN journal_entry_lines jel ON jel.journal_entry_id = je.id\n    WHERE je.reference_type = \u0027invoice\u0027\n    GROUP BY je.id\n    HAVING ABS(SUM(jel.debit_amount) - SUM(jel.credit_amount)) \u003e 0.01\n  ) sub;\n\n  IF v_unbalanced \u003e 0 THEN\n    RAISE EXCEPTION \u0027تحذير: % قيود invoice غير متوازنة بعد الإصلاح! يرجى المراجعة.\u0027, v_unbalanced;\n  ELSE\n    RAISE NOTICE \u0027تحقق: جميع قيود invoice متوازنة بعد الإصلاح ✓\u0027;\n  END IF;\nEND $$;\n\n-- ─────────────────────────────────────────────\n-- 4. إنشاء دالة مراجعة FIFO vs GL\n--    تُعيد: هل القيمة متطابقة؟\n-- ─────────────────────────────────────────────\nCREATE OR REPLACE FUNCTION public.reconcile_fifo_vs_gl(p_company_id UUID)\nRETURNS TABLE (\n  check_name        TEXT,\n  gl_value          NUMERIC,\n  fifo_value        NUMERIC,\n  difference        NUMERIC,\n  tolerance_pct     NUMERIC,\n  is_ok             BOOLEAN,\n  message           TEXT\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nDECLARE\n  v_gl_inventory   NUMERIC := 0;\n  v_fifo_inventory NUMERIC := 0;\n  v_gl_ar          NUMERIC := 0;\n  v_gl_ap          NUMERIC := 0;\n  v_gl_cash        NUMERIC := 0;\nBEGIN\n\n  -- 1) GL Inventory balance\n  SELECT COALESCE(SUM(jel.debit_amount - jel.credit_amount), 0) INTO v_gl_inventory\n  FROM journal_entry_lines jel\n  JOIN journal_entries je ON je.id = jel.journal_entry_id\n  JOIN chart_of_accounts coa ON coa.id = jel.account_id\n  WHERE je.company_id = p_company_id\n    AND je.status = \u0027posted\u0027\n    AND (coa.sub_type = \u0027inventory\u0027 OR coa.account_name ILIKE \u0027%مخزون%\u0027)\n    AND coa.account_type = \u0027asset\u0027;\n\n  -- 2) FIFO Engine value (sum of remaining_quantity × unit_cost)\n  SELECT COALESCE(SUM(fcl.remaining_quantity * fcl.unit_cost), 0) INTO v_fifo_inventory\n  FROM fifo_cost_lots fcl\n  JOIN products p ON p.id = fcl.product_id\n  WHERE p.company_id = p_company_id\n    AND fcl.remaining_quantity \u003e 0;\n\n  -- 3) GL Accounts Receivable\n  SELECT COALESCE(SUM(jel.debit_amount - jel.credit_amount), 0) INTO v_gl_ar\n  FROM journal_entry_lines jel\n  JOIN journal_entries je ON je.id = jel.journal_entry_id\n  JOIN chart_of_accounts coa ON coa.id = jel.account_id\n  WHERE je.company_id = p_company_id\n    AND je.status = \u0027posted\u0027\n    AND (coa.sub_type IN (\u0027accounts_receivable\u0027,\u0027ar\u0027) OR coa.account_name ILIKE \u0027%العملاء%\u0027 OR coa.account_name ILIKE \u0027%الذمم المدينة%\u0027)\n    AND coa.account_type = \u0027asset\u0027;\n\n  -- 4) GL Accounts Payable\n  SELECT COALESCE(SUM(jel.credit_amount - jel.debit_amount), 0) INTO v_gl_ap\n  FROM journal_entry_lines jel\n  JOIN journal_entries je ON je.id = jel.journal_entry_id\n  JOIN chart_of_accounts coa ON coa.id = jel.account_id\n  WHERE je.company_id = p_company_id\n    AND je.status = \u0027posted\u0027\n    AND (coa.sub_type IN (\u0027accounts_payable\u0027,\u0027ap\u0027) OR coa.account_name ILIKE \u0027%الموردين%\u0027 OR coa.account_name ILIKE \u0027%الذمم الدائنة%\u0027)\n    AND coa.account_type = \u0027liability\u0027;\n\n  -- 5) GL Cash/Bank\n  SELECT COALESCE(SUM(jel.debit_amount - jel.credit_amount), 0) INTO v_gl_cash\n  FROM journal_entry_lines jel\n  JOIN journal_entries je ON je.id = jel.journal_entry_id\n  JOIN chart_of_accounts coa ON coa.id = jel.account_id\n  WHERE je.company_id = p_company_id\n    AND je.status = \u0027posted\u0027\n    AND coa.account_type = \u0027asset\u0027\n    AND (coa.sub_type IN (\u0027cash\u0027,\u0027bank\u0027) OR coa.account_name ILIKE \u0027%بنك%\u0027 OR coa.account_name ILIKE \u0027%صندوق%\u0027 OR coa.account_name ILIKE \u0027%نقد%\u0027);\n\n  -- ─── Return results ───\n  RETURN QUERY VALUES\n    (\u0027GL vs FIFO Inventory\u0027,\n     v_gl_inventory, v_fifo_inventory,\n     ABS(v_gl_inventory - v_fifo_inventory),\n     CASE WHEN v_gl_inventory = 0 THEN 100 ELSE ROUND(ABS(v_gl_inventory - v_fifo_inventory) / v_gl_inventory * 100, 2) END,\n     ABS(v_gl_inventory - v_fifo_inventory) \u003c 1,  -- tolerance: £1\n     CASE WHEN ABS(v_gl_inventory - v_fifo_inventory) \u003c 1\n          THEN \u0027✓ GL Inventory = FIFO Value (مطابق)\u0027\n          ELSE \u0027✗ تضارب: GL=\u0027 || v_gl_inventory::TEXT || \u0027 FIFO=\u0027 || v_fifo_inventory::TEXT END\n    ),\n    (\u0027GL Accounts Receivable\u0027,\n     v_gl_ar, v_gl_ar,\n     0, 0, true,\n     \u0027✓ GL AR = \u0027 || v_gl_ar::TEXT\n    ),\n    (\u0027GL Accounts Payable\u0027,\n     v_gl_ap, v_gl_ap,\n     0, 0, true,\n     \u0027✓ GL AP = \u0027 || v_gl_ap::TEXT\n    ),\n    (\u0027GL Cash \u0026 Bank Balance\u0027,\n     v_gl_cash, v_gl_cash,\n     0, 0, true,\n     \u0027✓ GL Cash = \u0027 || v_gl_cash::TEXT\n    );\nEND;\n$$;\n\n-- ─────────────────────────────────────────────\n-- 5. إنشاء دالة backfill FIFO lots من المشتريات الموجودة\n--    تُنشئ fifo_cost_lots لكل فاتورة شراء (bill) معتمدة لا يوجد لها lot\n-- ─────────────────────────────────────────────\nCREATE OR REPLACE FUNCTION public.backfill_fifo_lots_from_bills(p_company_id UUID)\nRETURNS TABLE (\n  bill_number TEXT,\n  product_name TEXT,\n  quantity_added NUMERIC,\n  unit_cost NUMERIC,\n  lot_id UUID,\n  status TEXT\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nDECLARE\n  v_bill    RECORD;\n  v_item    RECORD;\n  v_lot_id  UUID;\n  v_unit_cost NUMERIC;\nBEGIN\n  -- لكل فاتورة شراء مرحَّلة أو مدفوعة\n  FOR v_bill IN\n    SELECT b.id, b.bill_number, b.bill_date, b.branch_id, b.warehouse_id, b.cost_center_id\n    FROM bills b\n    WHERE b.company_id = p_company_id\n      AND b.status IN (\u0027posted\u0027,\u0027paid\u0027,\u0027partial\u0027)\n    ORDER BY b.bill_date ASC\n  LOOP\n    -- لكل بند في الفاتورة\n    FOR v_item IN\n      SELECT bi.product_id, bi.quantity, bi.unit_price, bi.total_amount,\n             p.product_name, p.id as pid\n      FROM bill_items bi\n      JOIN products p ON p.id = bi.product_id\n      WHERE bi.bill_id = v_bill.id\n        AND bi.quantity \u003e 0\n        AND p.is_service = false  -- منتجات مخزنية فقط\n    LOOP\n      v_unit_cost := COALESCE(v_item.unit_price, \n                              CASE WHEN v_item.quantity \u003e 0 THEN v_item.total_amount / v_item.quantity ELSE 0 END,\n                              0);\n\n      -- تحقق: هل يوجد lot سابق لهذا البند؟\n      IF NOT EXISTS (\n        SELECT 1 FROM fifo_cost_lots\n        WHERE product_id    = v_item.product_id\n          AND reference_type = \u0027purchase\u0027\n          AND reference_id   = v_bill.id\n      ) THEN\n        -- إنشاء lot جديد\n        INSERT INTO fifo_cost_lots (\n          product_id, lot_date, lot_type,\n          original_quantity, remaining_quantity,\n          unit_cost, reference_type, reference_id,\n          branch_id, warehouse_id\n        )\n        VALUES (\n          v_item.product_id,\n          v_bill.bill_date,\n          \u0027purchase\u0027,\n          v_item.quantity,\n          v_item.quantity,  -- الكمية المتبقية = الكمية الأصلية (سنُطبَّق الاستهلاك لاحقاً)\n          v_unit_cost,\n          \u0027purchase\u0027,\n          v_bill.id,\n          v_bill.branch_id,\n          v_bill.warehouse_id\n        )\n        RETURNING id INTO v_lot_id;\n\n        RETURN QUERY VALUES (\n          v_bill.bill_number::TEXT,\n          v_item.product_name::TEXT,\n          v_item.quantity,\n          v_unit_cost,\n          v_lot_id,\n          \u0027created\u0027::TEXT\n        );\n      ELSE\n        RETURN QUERY VALUES (\n          v_bill.bill_number::TEXT,\n          v_item.product_name::TEXT,\n          v_item.quantity,\n          v_unit_cost,\n          NULL::UUID,\n          \u0027already_exists\u0027::TEXT\n        );\n      END IF;\n    END LOOP;\n  END LOOP;\nEND;\n$$;\n\n-- ─────────────────────────────────────────────\n-- 6. دالة تطبيق استهلاك FIFO من المبيعات الموجودة\n--    تُنقص remaining_quantity في fifo_cost_lots بحسب الفواتير المباعة\n-- ─────────────────────────────────────────────\nCREATE OR REPLACE FUNCTION public.apply_fifo_consumption_from_invoices(p_company_id UUID)\nRETURNS TABLE (\n  invoice_number TEXT,\n  product_name TEXT,\n  quantity_consumed NUMERIC,\n  cogs_calculated NUMERIC,\n  status TEXT\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nDECLARE\n  v_inv     RECORD;\n  v_item    RECORD;\n  v_lot     RECORD;\n  v_needed  NUMERIC;\n  v_consume NUMERIC;\n  v_total_cogs NUMERIC;\nBEGIN\n  -- لكل فاتورة مبيعات مرحَّلة\n  FOR v_inv IN\n    SELECT i.id, i.invoice_number\n    FROM invoices i\n    WHERE i.company_id = p_company_id\n      AND i.status IN (\u0027sent\u0027,\u0027paid\u0027,\u0027partially_paid\u0027,\u0027posted\u0027)\n    ORDER BY i.invoice_date ASC\n  LOOP\n    -- لكل بند في الفاتورة\n    FOR v_item IN\n      SELECT ii.product_id, ii.quantity, p.product_name\n      FROM invoice_items ii\n      JOIN products p ON p.id = ii.product_id\n      WHERE ii.invoice_id = v_inv.id\n        AND ii.quantity \u003e 0\n        AND p.is_service = false\n    LOOP\n      v_needed    := v_item.quantity;\n      v_total_cogs := 0;\n\n      -- استهلاك من lots بترتيب FIFO (الأقدم أولاً)\n      FOR v_lot IN\n        SELECT id, remaining_quantity, unit_cost\n        FROM fifo_cost_lots\n        WHERE product_id = v_item.product_id\n          AND remaining_quantity \u003e 0\n        ORDER BY lot_date ASC, created_at ASC\n      LOOP\n        EXIT WHEN v_needed \u003c= 0;\n\n        v_consume := LEAST(v_needed, v_lot.remaining_quantity);\n\n        UPDATE fifo_cost_lots\n        SET remaining_quantity = remaining_quantity - v_consume\n        WHERE id = v_lot.id;\n\n        v_total_cogs := v_total_cogs + (v_consume * v_lot.unit_cost);\n        v_needed     := v_needed - v_consume;\n      END LOOP;\n\n      RETURN QUERY VALUES (\n        v_inv.invoice_number::TEXT,\n        v_item.product_name::TEXT,\n        v_item.quantity,\n        v_total_cogs,\n        CASE WHEN v_needed \u003e 0 THEN \u0027insufficient_stock\u0027 ELSE \u0027ok\u0027 END::TEXT\n      );\n    END LOOP;\n  END LOOP;\nEND;\n$$;\n\n-- ─────────────────────────────────────────────\n-- 7. تطبيق استهلاك مرتجعات الشراء (تُعيد remaining_quantity)\n-- ─────────────────────────────────────────────\nCREATE OR REPLACE FUNCTION public.apply_purchase_returns_to_fifo(p_company_id UUID)\nRETURNS TABLE (\n  return_ref TEXT,\n  product_name TEXT,\n  quantity_returned NUMERIC,\n  status TEXT\n)\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nDECLARE\n  v_ret  RECORD;\n  v_item RECORD;\n  v_lot  RECORD;\n  v_remaining NUMERIC;\nBEGIN\n  -- لكل مرتجع شراء مكتمل\n  FOR v_ret IN\n    SELECT pr.id, pr.return_number, pr.bill_id\n    FROM purchase_returns pr\n    JOIN bills b ON b.id = pr.bill_id\n    WHERE b.company_id = p_company_id\n      AND pr.status = \u0027completed\u0027\n    ORDER BY pr.created_at ASC\n  LOOP\n    FOR v_item IN\n      SELECT pri.product_id, pri.quantity, p.product_name\n      FROM purchase_return_items pri\n      JOIN products p ON p.id = pri.product_id\n      WHERE pri.purchase_return_id = v_ret.id\n        AND pri.quantity \u003e 0\n        AND p.is_service = false\n    LOOP\n      -- إعادة الكمية إلى lot الأصلي للفاتورة\n      v_remaining := v_item.quantity;\n\n      FOR v_lot IN\n        SELECT id, original_quantity, remaining_quantity\n        FROM fifo_cost_lots\n        WHERE product_id    = v_item.product_id\n          AND reference_id  = v_ret.bill_id\n          AND reference_type = \u0027purchase\u0027\n        ORDER BY lot_date ASC\n      LOOP\n        EXIT WHEN v_remaining \u003c= 0;\n        -- نُعيد بقدر ما يمكن (لا نتجاوز original_quantity)\n        DECLARE\n          v_can_restore NUMERIC;\n        BEGIN\n          v_can_restore := LEAST(v_remaining, v_lot.original_quantity - v_lot.remaining_quantity);\n          IF v_can_restore \u003e 0 THEN\n            UPDATE fifo_cost_lots\n            SET remaining_quantity = remaining_quantity + v_can_restore\n            WHERE id = v_lot.id;\n            v_remaining := v_remaining - v_can_restore;\n          END IF;\n        END;\n      END LOOP;\n\n      RETURN QUERY VALUES (\n        v_ret.return_number::TEXT,\n        v_item.product_name::TEXT,\n        v_item.quantity,\n        \u0027ok\u0027::TEXT\n      );\n    END LOOP;\n  END LOOP;\nEND;\n$$;\n\nCOMMIT;\n\n-- ──────────────────────────────────────────────────────────────\n-- 8. تعليمات تشغيل الـ Backfill يدوياً في Supabase SQL Editor\n--    (يُشغَّل مرة واحدة بعد تطبيق هذه Migration)\n-- ──────────────────────────────────────────────────────────────\n-- الخطوة 1: إنشاء FIFO lots من المشتريات الموجودة\n--   SELECT * FROM public.backfill_fifo_lots_from_bills(\u0027\u003ccompany_id\u003e\u0027);\n--\n-- الخطوة 2: تطبيق استهلاك المبيعات على الـ lots\n--   SELECT * FROM public.apply_fifo_consumption_from_invoices(\u0027\u003ccompany_id\u003e\u0027);\n--\n-- الخطوة 3: تطبيق مرتجعات الشراء\n--   SELECT * FROM public.apply_purchase_returns_to_fifo(\u0027\u003ccompany_id\u003e\u0027);\n--\n-- الخطوة 4: مراجعة FIFO vs GL\n--   SELECT * FROM public.reconcile_fifo_vs_gl(\u0027\u003ccompany_id\u003e\u0027);\n-- ──────────────────────────────────────────────────────────────\n","PSPath":"C:\\Users\\abuel\\Documents\\trae_projects\\ERB_VitaSlims\\supabase\\migrations\\20260221_008_fix_double_cogs_and_fifo.sql","PSParentPath":"C:\\Users\\abuel\\Documents\\trae_projects\\ERB_VitaSlims\\supabase\\migrations","PSChildName":"20260221_008_fix_double_cogs_and_fifo.sql","PSDrive":{"CurrentLocation":"Users\\abuel\\Documents\\trae_projects\\ERB_VitaSlims","Name":"C","Provider":{"ImplementingType":"Microsoft.PowerShell.Commands.FileSystemProvider","HelpFile":"System.Management.Automation.dll-Help.xml","Name":"FileSystem","PSSnapIn":"Microsoft.PowerShell.Core","ModuleName":"Microsoft.PowerShell.Core","Module":null,"Description":"","Capabilities":52,"Home":"C:\\Users\\abuel","Drives":"C D E"},"Root":"C:\\","Description":"Windows","MaximumSize":null,"Credential":{"UserName":null,"Password":null},"DisplayRoot":null},"PSProvider":{"ImplementingType":{"Module":"System.Management.Automation.dll","Assembly":"System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35","TypeHandle":"System.RuntimeTypeHandle","DeclaringMethod":null,"BaseType":"System.Management.Automation.Provider.NavigationCmdletProvider","UnderlyingSystemType":"Microsoft.PowerShell.Commands.FileSystemProvider","FullName":"Microsoft.PowerShell.Commands.FileSystemProvider","AssemblyQualifiedName":"Microsoft.PowerShell.Commands.FileSystemProvider, System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35","Namespace":"Microsoft.PowerShell.Commands","GUID":"b4755d19-b6a7-38dc-ae06-4167f801062f","IsEnum":false,"GenericParameterAttributes":null,"IsSecurityCritical":true,"IsSecuritySafeCritical":false,"IsSecurityTransparent":false,"IsGenericTypeDefinition":false,"IsGenericParameter":false,"GenericParameterPosition":null,"IsGenericType":false,"IsConstructedGenericType":false,"ContainsGenericParameters":false,"StructLayoutAttribute":"System.Runtime.InteropServices.StructLayoutAttribute","Name":"FileSystemProvider","MemberType":32,"DeclaringType":null,"ReflectedType":null,"MetadataToken":33556356,"GenericTypeParameters":"","DeclaredConstructors":"Void .ctor() Void .cctor()","DeclaredEvents":"","DeclaredFields":"System.Collections.ObjectModel.Collection`1[System.Management.Automation.WildcardPattern] excludeMatcher System.Management.Automation.PSTraceSource tracer Int32 FILETRANSFERSIZE System.String ProviderName","DeclaredMembers":"System.String NormalizePath(System.String) System.IO.FileSystemInfo GetFileSystemInfo(System.String, Boolean ByRef) Boolean IsFilterSet() System.Object GetChildNamesDynamicParameters(System.String) System.Object GetChildItemsDynamicParameters(System.String, Boolean) System.Object CopyItemDynamicParameters(System.String, System.String, Boolean) Boolean IsNetworkMappedDrive(System.Management.Automation.PSDriveInfo) Boolean IsSupportedDriveForPersistence(System.Management.Automation.PSDriveInfo) System.String GetRootPathForNetworkDriveOrDosDevice(System.IO.DriveInfo) System.Collections.ObjectModel.Collection`1[System.Management.Automation.PSDriveInfo] InitializeDefaultDrives() System.Object GetItemDynamicParameters(System.String) Void InvokeDefaultAction(System.String) Void GetChildItems(System.String, Boolean, UInt32) Void GetChildNames(System.String, System.Management.Automation.ReturnContainers) Boolean CheckItemExists(System.String, Boolean ByRef) System.Object RemoveItemDynamicParameters(System.String, Boolean) Void RemoveFileInfoItem(System.IO.FileInfo, Boolean) Boolean ItemExists(System.String) System.Object ItemExistsDynamicParameters(System.String) Boolean HasChildItems(System.String) Void CopyItemLocalOrToSession(System.String, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) Void InitilizeFunctionPSCopyFileFromRemoteSession(System.Management.Automation.PowerShell) Boolean ValidRemoteSessionForScripting(System.Management.Automation.Runspaces.Runspace) Void InitilizeFunctionsPSCopyFileToRemoteSession(System.Management.Automation.PowerShell) Boolean PathIsReservedDeviceName(System.String, System.String) Boolean IsAbsolutePath(System.String) System.String GetCommonBase(System.String, System.String) System.String CreateNormalizedRelativePathFromStack(System.Collections.Generic.Stack`1[System.String]) Boolean IsItemContainer(System.String) Void MoveDirectoryInfoUnchecked(System.IO.DirectoryInfo, System.String, Boolean) Boolean IsSameVolume(System.String, System.String) System.Object GetPropertyDynamicParameters(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Object SetPropertyDynamicParameters(System.String, System.Management.Automation.PSObject) System.Object ClearPropertyDynamicParameters(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Object GetContentWriterDynamicParameters(System.String) System.Object ClearContentDynamicParameters(System.String) Int32 SafeGetFileAttributes(System.String) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptorFromPath(System.String, System.Security.AccessControl.AccessControlSections) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptorOfType(System.String, System.Security.AccessControl.AccessControlSections) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptor(ItemType) System.Management.Automation.ErrorRecord CreateErrorRecord(System.String, System.String) System.String GetHelpMaml(System.String, System.String) System.Management.Automation.ProviderInfo Start(System.Management.Automation.ProviderInfo) System.Management.Automation.PSDriveInfo NewDrive(System.Management.Automation.PSDriveInfo) Void MapNetworkDrive(System.Management.Automation.PSDriveInfo) System.Management.Automation.PSDriveInfo RemoveDrive(System.Management.Automation.PSDriveInfo) System.String GetUNCForNetworkDrive(System.String) System.String GetSubstitutedPathForNetworkDosDevice(System.String) Boolean IsValidPath(System.String) Void GetItem(System.String) System.IO.FileSystemInfo GetFileSystemItem(System.String, Boolean ByRef, Boolean) Boolean ConvertPath(System.String, System.String, System.String ByRef, System.String ByRef) Void GetPathItems(System.String, Boolean, UInt32, Boolean, System.Management.Automation.ReturnContainers) Void Dir(System.IO.DirectoryInfo, Boolean, UInt32, Boolean, System.Management.Automation.ReturnContainers, InodeTracker) System.Management.Automation.FlagsExpression`1[System.IO.FileAttributes] FormatAttributeSwitchParamters() System.String Mode(System.Management.Automation.PSObject) Void RenameItem(System.String, System.String) Void NewItem(System.String, System.String, System.Object) ItemType GetItemType(System.String) Void CreateDirectory(System.String, Boolean) Boolean CreateIntermediateDirectories(System.String) Void RemoveItem(System.String, Boolean) Void RemoveDirectoryInfoItem(System.IO.DirectoryInfo, Boolean, Boolean, Boolean) Void RemoveFileSystemItem(System.IO.FileSystemInfo, Boolean) Boolean ItemExists(System.String, System.Management.Automation.ErrorRecord ByRef) Boolean DirectoryInfoHasChildItems(System.IO.DirectoryInfo) Void CopyItem(System.String, System.String, Boolean) Void CopyItemFromRemoteSession(System.String, System.String, Boolean, Boolean, System.Management.Automation.Runspaces.PSSession) Void CopyDirectoryInfoItem(System.IO.DirectoryInfo, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) Void CopyFileInfoItem(System.IO.FileInfo, System.String, Boolean, System.Management.Automation.PowerShell) Void CopyDirectoryFromRemoteSession(System.String, System.String, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) System.Collections.ArrayList GetRemoteSourceAlternateStreams(System.Management.Automation.PowerShell, System.String) Void RemoveFunctionsPSCopyFileFromRemoteSession(System.Management.Automation.PowerShell) System.Collections.Hashtable GetRemoteFileMetadata(System.String, System.Management.Automation.PowerShell) Void SetFileMetadata(System.String, System.IO.FileInfo, System.Management.Automation.PowerShell) Void CopyFileFromRemoteSession(System.String, System.String, System.String, Boolean, System.Management.Automation.PowerShell, Int64) Boolean PerformCopyFileFromRemoteSession(System.String, System.IO.FileInfo, System.String, Boolean, System.Management.Automation.PowerShell, Int64, Boolean, System.String) Void RemoveFunctionPSCopyFileToRemoteSession(System.Management.Automation.PowerShell) Boolean RemoteTargetSupportsAlternateStreams(System.Management.Automation.PowerShell, System.String) System.String MakeRemotePath(System.Management.Automation.PowerShell, System.String, System.String) Boolean RemoteDirectoryExist(System.Management.Automation.PowerShell, System.String) Boolean CopyFileStreamToRemoteSession(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell, Boolean, System.String) System.Collections.Hashtable GetFileMetadata(System.IO.FileInfo) Void SetRemoteFileMetadata(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell) Boolean PerformCopyFileToRemoteSession(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell) Boolean RemoteDestinationPathIsFile(System.String, System.Management.Automation.PowerShell) System.String CreateDirectoryOnRemoteSession(System.String, Boolean, System.Management.Automation.PowerShell) System.String GetParentPath(System.String, System.String) Boolean IsUNCPath(System.String) Boolean IsUNCRoot(System.String) Boolean IsPathRoot(System.String) System.String NormalizeRelativePath(System.String, System.String) System.String NormalizeRelativePathHelper(System.String, System.String) System.String RemoveRelativeTokens(System.String) System.Collections.Generic.Stack`1[System.String] TokenizePathToStack(System.String, System.String) System.Collections.Generic.Stack`1[System.String] NormalizeThePath(System.String, System.Collections.Generic.Stack`1[System.String]) System.String GetChildName(System.String) System.String EnsureDriveIsRooted(System.String) Void MoveItem(System.String, System.String) Void MoveFileInfoItem(System.IO.FileInfo, System.String, Boolean, Boolean) Void MoveDirectoryInfoItem(System.IO.DirectoryInfo, System.String, Boolean) Void CopyAndDelete(System.IO.DirectoryInfo, System.String, Boolean) Void GetProperty(System.String, System.Collections.ObjectModel.Collection`1[System.String]) Void SetProperty(System.String, System.Management.Automation.PSObject) Void ClearProperty(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Management.Automation.Provider.IContentReader GetContentReader(System.String) System.Object GetContentReaderDynamicParameters(System.String) System.Management.Automation.Provider.IContentWriter GetContentWriter(System.String) Void ClearContent(System.String) Void ValidateParameters(Boolean) Void GetSecurityDescriptor(System.String, System.Security.AccessControl.AccessControlSections) Void SetSecurityDescriptor(System.String, System.Security.AccessControl.ObjectSecurity) Void SetSecurityDescriptor(System.String, System.Security.AccessControl.ObjectSecurity, System.Security.AccessControl.AccessControlSections) Void \u003cRemoveDirectoryInfoItem\u003eg__WriteErrorHelper|43_0(System.Exception, \u003c\u003ec__DisplayClass43_0 ByRef) Void .ctor() Void .cctor() System.Collections.ObjectModel.Collection`1[System.Management.Automation.WildcardPattern] excludeMatcher System.Management.Automation.PSTraceSource tracer Int32 FILETRANSFERSIZE System.String ProviderName Microsoft.PowerShell.Commands.FileSystemProvider+ItemType Microsoft.PowerShell.Commands.FileSystemProvider+NativeMethods Microsoft.PowerShell.Commands.FileSystemProvider+NetResource Microsoft.PowerShell.Commands.FileSystemProvider+InodeTracker Microsoft.PowerShell.Commands.FileSystemProvider+\u003c\u003ec__DisplayClass43_0","DeclaredMethods":"System.String Mode(System.Management.Automation.PSObject) System.String NormalizePath(System.String) System.IO.FileSystemInfo GetFileSystemInfo(System.String, Boolean ByRef) Boolean IsFilterSet() System.Object GetChildNamesDynamicParameters(System.String) System.Object GetChildItemsDynamicParameters(System.String, Boolean) System.Object CopyItemDynamicParameters(System.String, System.String, Boolean) Boolean IsNetworkMappedDrive(System.Management.Automation.PSDriveInfo) Boolean IsSupportedDriveForPersistence(System.Management.Automation.PSDriveInfo) System.String GetRootPathForNetworkDriveOrDosDevice(System.IO.DriveInfo) System.Collections.ObjectModel.Collection`1[System.Management.Automation.PSDriveInfo] InitializeDefaultDrives() System.Object GetItemDynamicParameters(System.String) Void InvokeDefaultAction(System.String) Void GetChildItems(System.String, Boolean, UInt32) Void GetChildNames(System.String, System.Management.Automation.ReturnContainers) Boolean CheckItemExists(System.String, Boolean ByRef) System.Object RemoveItemDynamicParameters(System.String, Boolean) Void RemoveFileInfoItem(System.IO.FileInfo, Boolean) Boolean ItemExists(System.String) System.Object ItemExistsDynamicParameters(System.String) Boolean HasChildItems(System.String) Void CopyItemLocalOrToSession(System.String, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) Void InitilizeFunctionPSCopyFileFromRemoteSession(System.Management.Automation.PowerShell) Boolean ValidRemoteSessionForScripting(System.Management.Automation.Runspaces.Runspace) Void InitilizeFunctionsPSCopyFileToRemoteSession(System.Management.Automation.PowerShell) Boolean PathIsReservedDeviceName(System.String, System.String) Boolean IsAbsolutePath(System.String) System.String GetCommonBase(System.String, System.String) System.String CreateNormalizedRelativePathFromStack(System.Collections.Generic.Stack`1[System.String]) Boolean IsItemContainer(System.String) Void MoveDirectoryInfoUnchecked(System.IO.DirectoryInfo, System.String, Boolean) Boolean IsSameVolume(System.String, System.String) System.Object GetPropertyDynamicParameters(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Object SetPropertyDynamicParameters(System.String, System.Management.Automation.PSObject) System.Object ClearPropertyDynamicParameters(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Object GetContentWriterDynamicParameters(System.String) System.Object ClearContentDynamicParameters(System.String) Int32 SafeGetFileAttributes(System.String) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptorFromPath(System.String, System.Security.AccessControl.AccessControlSections) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptorOfType(System.String, System.Security.AccessControl.AccessControlSections) System.Security.AccessControl.ObjectSecurity NewSecurityDescriptor(ItemType) System.Management.Automation.ErrorRecord CreateErrorRecord(System.String, System.String) System.String GetHelpMaml(System.String, System.String) System.Management.Automation.ProviderInfo Start(System.Management.Automation.ProviderInfo) System.Management.Automation.PSDriveInfo NewDrive(System.Management.Automation.PSDriveInfo) Void MapNetworkDrive(System.Management.Automation.PSDriveInfo) System.Management.Automation.PSDriveInfo RemoveDrive(System.Management.Automation.PSDriveInfo) System.String GetUNCForNetworkDrive(System.String) System.String GetSubstitutedPathForNetworkDosDevice(System.String) Boolean IsValidPath(System.String) Void GetItem(System.String) System.IO.FileSystemInfo GetFileSystemItem(System.String, Boolean ByRef, Boolean) Boolean ConvertPath(System.String, System.String, System.String ByRef, System.String ByRef) Void GetPathItems(System.String, Boolean, UInt32, Boolean, System.Management.Automation.ReturnContainers) Void Dir(System.IO.DirectoryInfo, Boolean, UInt32, Boolean, System.Management.Automation.ReturnContainers, InodeTracker) System.Management.Automation.FlagsExpression`1[System.IO.FileAttributes] FormatAttributeSwitchParamters() Void RenameItem(System.String, System.String) Void NewItem(System.String, System.String, System.Object) ItemType GetItemType(System.String) Void CreateDirectory(System.String, Boolean) Boolean CreateIntermediateDirectories(System.String) Void RemoveItem(System.String, Boolean) Void RemoveDirectoryInfoItem(System.IO.DirectoryInfo, Boolean, Boolean, Boolean) Void RemoveFileSystemItem(System.IO.FileSystemInfo, Boolean) Boolean ItemExists(System.String, System.Management.Automation.ErrorRecord ByRef) Boolean DirectoryInfoHasChildItems(System.IO.DirectoryInfo) Void CopyItem(System.String, System.String, Boolean) Void CopyItemFromRemoteSession(System.String, System.String, Boolean, Boolean, System.Management.Automation.Runspaces.PSSession) Void CopyDirectoryInfoItem(System.IO.DirectoryInfo, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) Void CopyFileInfoItem(System.IO.FileInfo, System.String, Boolean, System.Management.Automation.PowerShell) Void CopyDirectoryFromRemoteSession(System.String, System.String, System.String, Boolean, Boolean, System.Management.Automation.PowerShell) System.Collections.ArrayList GetRemoteSourceAlternateStreams(System.Management.Automation.PowerShell, System.String) Void RemoveFunctionsPSCopyFileFromRemoteSession(System.Management.Automation.PowerShell) System.Collections.Hashtable GetRemoteFileMetadata(System.String, System.Management.Automation.PowerShell) Void SetFileMetadata(System.String, System.IO.FileInfo, System.Management.Automation.PowerShell) Void CopyFileFromRemoteSession(System.String, System.String, System.String, Boolean, System.Management.Automation.PowerShell, Int64) Boolean PerformCopyFileFromRemoteSession(System.String, System.IO.FileInfo, System.String, Boolean, System.Management.Automation.PowerShell, Int64, Boolean, System.String) Void RemoveFunctionPSCopyFileToRemoteSession(System.Management.Automation.PowerShell) Boolean RemoteTargetSupportsAlternateStreams(System.Management.Automation.PowerShell, System.String) System.String MakeRemotePath(System.Management.Automation.PowerShell, System.String, System.String) Boolean RemoteDirectoryExist(System.Management.Automation.PowerShell, System.String) Boolean CopyFileStreamToRemoteSession(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell, Boolean, System.String) System.Collections.Hashtable GetFileMetadata(System.IO.FileInfo) Void SetRemoteFileMetadata(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell) Boolean PerformCopyFileToRemoteSession(System.IO.FileInfo, System.String, System.Management.Automation.PowerShell) Boolean RemoteDestinationPathIsFile(System.String, System.Management.Automation.PowerShell) System.String CreateDirectoryOnRemoteSession(System.String, Boolean, System.Management.Automation.PowerShell) System.String GetParentPath(System.String, System.String) Boolean IsUNCPath(System.String) Boolean IsUNCRoot(System.String) Boolean IsPathRoot(System.String) System.String NormalizeRelativePath(System.String, System.String) System.String NormalizeRelativePathHelper(System.String, System.String) System.String RemoveRelativeTokens(System.String) System.Collections.Generic.Stack`1[System.String] TokenizePathToStack(System.String, System.String) System.Collections.Generic.Stack`1[System.String] NormalizeThePath(System.String, System.Collections.Generic.Stack`1[System.String]) System.String GetChildName(System.String) System.String EnsureDriveIsRooted(System.String) Void MoveItem(System.String, System.String) Void MoveFileInfoItem(System.IO.FileInfo, System.String, Boolean, Boolean) Void MoveDirectoryInfoItem(System.IO.DirectoryInfo, System.String, Boolean) Void CopyAndDelete(System.IO.DirectoryInfo, System.String, Boolean) Void GetProperty(System.String, System.Collections.ObjectModel.Collection`1[System.String]) Void SetProperty(System.String, System.Management.Automation.PSObject) Void ClearProperty(System.String, System.Collections.ObjectModel.Collection`1[System.String]) System.Management.Automation.Provider.IContentReader GetContentReader(System.String) System.Object GetContentReaderDynamicParameters(System.String) System.Management.Automation.Provider.IContentWriter GetContentWriter(System.String) Void ClearContent(System.String) Void ValidateParameters(Boolean) Void GetSecurityDescriptor(System.String, System.Security.AccessControl.AccessControlSections) Void SetSecurityDescriptor(System.String, System.Security.AccessControl.ObjectSecurity) Void SetSecurityDescriptor(System.String, System.Security.AccessControl.ObjectSecurity, System.Security.AccessControl.AccessControlSections) Void \u003cRemoveDirectoryInfoItem\u003eg__WriteErrorHelper|43_0(System.Exception, \u003c\u003ec__DisplayClass43_0 ByRef)","DeclaredNestedTypes":"Microsoft.PowerShell.Commands.FileSystemProvider+ItemType Microsoft.PowerShell.Commands.FileSystemProvider+NativeMethods Microsoft.PowerShell.Commands.FileSystemProvider+NetResource Microsoft.PowerShell.Commands.FileSystemProvider+InodeTracker Microsoft.PowerShell.Commands.FileSystemProvider+\u003c\u003ec__DisplayClass43_0","DeclaredProperties":"","ImplementedInterfaces":"System.Management.Automation.IResourceSupplier System.Management.Automation.Provider.IContentCmdletProvider System.Management.Automation.Provider.IPropertyCmdletProvider System.Management.Automation.Provider.ISecurityDescriptorCmdletProvider System.Management.Automation.Provider.ICmdletProviderSupportsHelp","TypeInitializer":"Void .cctor()","IsNested":false,"Attributes":1048833,"IsVisible":true,"IsNotPublic":false,"IsPublic":true,"IsNestedPublic":false,"IsNestedPrivate":false,"IsNestedFamily":false,"IsNestedAssembly":false,"IsNestedFamANDAssem":false,"IsNestedFamORAssem":false,"IsAutoLayout":true,"IsLayoutSequential":false,"IsExplicitLayout":false,"IsClass":true,"IsInterface":false,"IsValueType":false,"IsAbstract":false,"IsSealed":true,"IsSpecialName":false,"IsImport":false,"IsSerializable":false,"IsAnsiClass":true,"IsUnicodeClass":false,"IsAutoClass":false,"IsArray":false,"IsByRef":false,"IsPointer":false,"IsPrimitive":false,"IsCOMObject":false,"HasElementType":false,"IsContextful":false,"IsMarshalByRef":false,"GenericTypeArguments":"","CustomAttributes":"[System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.String), typeof(System.IO.FileInfo) }, ProviderCmdlet = \"New-Item\")] [System.Management.Automation.OutputTypeAttribute(typeof(System.Security.AccessControl.FileSecurity), ProviderCmdlet = \"Set-Acl\")] [System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.String), typeof(System.Management.Automation.PathInfo) }, ProviderCmdlet = \"Resolve-Path\")] [System.Management.Automation.OutputTypeAttribute(typeof(System.Management.Automation.PathInfo), ProviderCmdlet = \"Push-Location\")] [System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.Byte), typeof(System.String) }, ProviderCmdlet = \"Get-Content\")] [System.Management.Automation.OutputTypeAttribute(typeof(System.IO.FileInfo), ProviderCmdlet = \"Get-Item\")] [System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.IO.FileInfo), typeof(System.IO.DirectoryInfo) }, ProviderCmdlet = \"Get-ChildItem\")] [System.Management.Automation.OutputTypeAttribute(new Type[2] { typeof(System.Security.AccessControl.FileSecurity), typeof(System.Security.AccessControl.DirectorySecurity) }, ProviderCmdlet = \"Get-Acl\")] [System.Management.Automation.OutputTypeAttribute(new Type[4] { typeof(System.Boolean), typeof(System.String), typeof(System.IO.FileInfo), typeof(System.IO.DirectoryInfo) }, ProviderCmdlet = \"Get-Item\")] [System.Management.Automation.OutputTypeAttribute(new Type[5] { typeof(System.Boolean), typeof(System.String), typeof(System.DateTime), typeof(System.IO.FileInfo), typeof(System.IO.DirectoryInfo) }, ProviderCmdlet = \"Get-ItemProperty\")] [System.Management.Automation.Provider.CmdletProviderAttribute(\"FileSystem\", (System.Management.Automation.Provider.ProviderCapabilities)52)]"},"HelpFile":"System.Management.Automation.dll-Help.xml","Name":"FileSystem","PSSnapIn":{"Name":"Microsoft.PowerShell.Core","IsDefault":true,"ApplicationBase":"C:\\Windows\\System32\\WindowsPowerShell\\v1.0","AssemblyName":"System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, ProcessorArchitecture=MSIL","ModuleName":"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\System.Management.Automation.dll","PSVersion":"5.1.26100.7859","Version":"3.0.0.0","Types":"types.ps1xml typesv3.ps1xml","Formats":"Certificate.format.ps1xml DotNetTypes.format.ps1xml FileSystem.format.ps1xml Help.format.ps1xml HelpV3.format.ps1xml PowerShellCore.format.ps1xml PowerShellTrace.format.ps1xml Registry.format.ps1xml","Description":"This Windows PowerShell snap-in contains cmdlets used to manage components of Windows PowerShell.","Vendor":"Microsoft Corporation","LogPipelineExecutionDetails":false},"ModuleName":"Microsoft.PowerShell.Core","Module":null,"Description":"","Capabilities":52,"Home":"C:\\Users\\abuel","Drives":["C","D","E"]},"ReadCount":1}
