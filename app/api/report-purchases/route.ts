/**
 * ðŸ“Š Purchases Report API - ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª
 * 
 * âš ï¸ OPERATIONAL REPORT (NOT ACCOUNTING REPORT)
 * 
 * âœ… Ù‡Ø°Ø§ ØªÙ‚Ø±ÙŠØ± ØªØ´ØºÙŠÙ„ÙŠ - ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ù† bills Ù…Ø¨Ø§Ø´Ø±Ø©
 * âœ… Ù„ÙŠØ³ ØªÙ‚Ø±ÙŠØ± Ù…Ø­Ø§Ø³Ø¨ÙŠ Ø±Ø³Ù…ÙŠ (Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…Ø­Ø§Ø³Ø¨ÙŠØ© ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ journal_entries ÙÙ‚Ø·)
 * 
 * âœ… Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯:
 * 1. Ù…ØµØ¯Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: bills Ùˆ bill_items (ØªØ´ØºÙŠÙ„ÙŠ)
 * 2. Ø§Ù„ØªØ¬Ù…ÙŠØ¹: Ø­Ø³Ø¨ Ø§Ù„Ù…ÙˆØ±Ø¯
 * 3. Ø§Ù„ÙÙ„ØªØ±Ø©: Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®ØŒ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ Ø§Ù„Ù…ÙˆØ±Ø¯ØŒ Ø§Ù„Ù…Ù†ØªØ¬ØŒ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù†ØµØ±
 * 4. Ø§Ù„ÙØ±ÙˆØ¹: Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„ÙØ±ÙˆØ¹ ÙˆÙ…Ø±Ø§ÙƒØ² Ø§Ù„ØªÙƒÙ„ÙØ©
 * 
 * âš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø© Ù…Ù‡Ù…Ø©:
 * - Ù‡Ø°Ø§ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ØªØ´ØºÙŠÙ„ÙŠ ÙˆÙ„ÙŠØ³ Ù…Ø­Ø§Ø³Ø¨ÙŠ Ø±Ø³Ù…ÙŠ
 * - Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…Ø­Ø§Ø³Ø¨ÙŠØ© Ø§Ù„Ø±Ø³Ù…ÙŠØ© ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ journal_entries ÙÙ‚Ø·
 * - Ù‡Ø°Ø§ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ÙŠØ³ØªØ®Ø¯Ù… bills Ù„ØªÙˆØ¶ÙŠØ­ ØªØ´ØºÙŠÙ„ÙŠ
 * 
 * Ø±Ø§Ø¬Ø¹: docs/ACCOUNTING_REPORTS_ARCHITECTURE.md
 */

import { createClient as createServerClient } from "@/lib/supabase/server"
import { createClient } from "@supabase/supabase-js"
import { secureApiRequest, serverError, badRequestError } from "@/lib/api-security-enhanced"
import { buildBranchFilter } from "@/lib/branch-access-control"
import { NextRequest, NextResponse } from "next/server"

export async function GET(req: NextRequest) {
  try {
    // âœ… Ø¥Ù†Ø´Ø§Ø¡ supabase client Ù„Ù„Ù…ØµØ§Ø¯Ù‚Ø©
    const authSupabase = await createServerClient()

    // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù…Ø§Ù†
    const { user, companyId, branchId, member, error } = await secureApiRequest(req, {
      requireAuth: true,
      requireCompany: true,
      requireBranch: true,
      requirePermission: { resource: "reports", action: "read" },
      supabase: authSupabase // âœ… ØªÙ…Ø±ÙŠØ± supabase client
    })

    if (error) return error
    if (!companyId) return badRequestError("Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø±ÙƒØ© Ù…Ø·Ù„ÙˆØ¨")
    if (!branchId) return badRequestError("Ù…Ø¹Ø±Ù Ø§Ù„ÙØ±Ø¹ Ù…Ø·Ù„ÙˆØ¨")

    const url = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL || ""
    const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || ""
    if (!url || !serviceKey) {
      return serverError(`Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø®Ø§Ø¯Ù…: ${"Server configuration error"}`)
    }

    const admin = createClient(url, serviceKey, { global: { headers: { apikey: serviceKey } } })
    const { searchParams } = new URL(req.url)
    const from = String(searchParams.get("from") || "0001-01-01")
    const to = String(searchParams.get("to") || "9999-12-31")
    const itemType = String(searchParams.get("item_type") || "all") // 'all', 'product', 'service'
    const statusFilter = String(searchParams.get("status") || "all") // 'all', 'received', 'paid', 'partially_paid'
    const supplierId = searchParams.get("supplier_id") || ""
    const productId = searchParams.get("product_id") || ""

    // âœ… Ø¬Ù„Ø¨ Ø§Ù„ÙÙˆØ§ØªÙŠØ± (ØªÙ‚Ø±ÙŠØ± ØªØ´ØºÙŠÙ„ÙŠ - Ù…Ù† bills Ù…Ø¨Ø§Ø´Ø±Ø©)
    // âš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ø§ ØªÙ‚Ø±ÙŠØ± ØªØ´ØºÙŠÙ„ÙŠ ÙˆÙ„ÙŠØ³ Ù…Ø­Ø§Ø³Ø¨ÙŠ Ø±Ø³Ù…ÙŠ
    let billsQuery = admin
      .from("bills")
      .select("id, total_amount, bill_date, status, supplier_id, suppliers(name)")
      .eq("company_id", companyId)
      .gte("bill_date", from)
      .lte("bill_date", to)

    // ØªØ·Ø¨ÙŠÙ‚ ÙÙ„ØªØ± Ø§Ù„Ø­Ø§Ù„Ø©
    if (statusFilter === "all") {
      billsQuery = billsQuery.in("status", ["received", "partially_paid", "paid"])
    } else {
      billsQuery = billsQuery.eq("status", statusFilter)
    }

    // ØªØ·Ø¨ÙŠÙ‚ ÙÙ„ØªØ± Ø§Ù„Ù…ÙˆØ±Ø¯
    if (supplierId) {
      billsQuery = billsQuery.eq("supplier_id", supplierId)
    }

    const { data: bills } = await billsQuery

    if (!bills || bills.length === 0) {
      return NextResponse.json({
      success: true,
      data: []
    })
    }

    const billIds = bills.map((b: any) => b.id)

    // Get bill items with product info
    let itemsQuery = admin
      .from("bill_items")
      .select("bill_id, line_total, product_id, products(item_type, name)")
      .in("bill_id", billIds)

    // ØªØ·Ø¨ÙŠÙ‚ ÙÙ„ØªØ± Ø§Ù„Ù…Ù†ØªØ¬ Ø¥Ø°Ø§ ØªÙ… ØªØ­Ø¯ÙŠØ¯Ù‡
    if (productId) {
      itemsQuery = itemsQuery.eq("product_id", productId)
    }

    const { data: billItems } = await itemsQuery

    // Build a map of bill_id -> { productTotal, serviceTotal }
    const billTotals = new Map<string, { productTotal: number; serviceTotal: number }>()
    for (const item of billItems || []) {
      const billId = String((item as any).bill_id)
      const lineTotal = Number((item as any).line_total || 0)
      const prodItemType = (item as any).products?.item_type || 'product'

      const existing = billTotals.get(billId) || { productTotal: 0, serviceTotal: 0 }
      if (prodItemType === 'service') {
        existing.serviceTotal += lineTotal
      } else {
        existing.productTotal += lineTotal
      }
      billTotals.set(billId, existing)
    }

    // Group by supplier with item type filtering
    const grouped: Record<string, { total: number; count: number; productPurchases: number; servicePurchases: number }> = {}
    for (const bill of bills) {
      const name = String(((bill as any).suppliers || {}).name || "Unknown")
      const billId = String((bill as any).id)
      const totals = billTotals.get(billId) || { productTotal: 0, serviceTotal: 0 }

      // Apply item type filter
      let relevantTotal = 0
      if (itemType === 'product') {
        relevantTotal = totals.productTotal
      } else if (itemType === 'service') {
        relevantTotal = totals.serviceTotal
      } else {
        relevantTotal = totals.productTotal + totals.serviceTotal
      }

      // Skip if no relevant purchases
      if (relevantTotal === 0) continue

      const prev = grouped[name] || { total: 0, count: 0, productPurchases: 0, servicePurchases: 0 }
      grouped[name] = {
        total: prev.total + relevantTotal,
        count: prev.count + 1,
        productPurchases: prev.productPurchases + totals.productTotal,
        servicePurchases: prev.servicePurchases + totals.serviceTotal
      }
    }

    const result = Object.entries(grouped).map(([supplier_name, v]) => ({
      supplier_name,
      total_purchases: v.total,
      bill_count: v.count,
      product_purchases: v.productPurchases,
      service_purchases: v.servicePurchases
    }))
    return NextResponse.json({
      success: true,
      data: result
    })
  } catch (e: any) {
    return serverError(`Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª: ${e?.message}`)
  }
}