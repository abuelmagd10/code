# تقرير مراجعة مشروع ERB على مستوى Enterprise ERP

**تاريخ التقرير:** 2026-02-21  
**نطاق المراجعة:** تقني، محاسبي، أمني، معماري، أداء، UX، AI، سيناريوهات الفشل  
**معيار التقييم:** بدون مجاملات — تقييم قابل للعرض على شركة كبيرة أو مستثمر

---

## ملخص تنفيذي

المشروع يطبق **منهجية محاسبية سليمة** في القلب (GL كمصدر للحقيقة، قيود مزدوجة، COGS، FIFO، إقفال فترات)، وتوجد **عمليات ذرية** لترحيل الفواتير والمدفوعات عبر RPC. لكن هناك **فجوات حرجة** في: تطبيق Period Lock على جميع المسارات (بما فيها APIs)، توحيد مصدر بيانات الـ Dashboard مع P&L، RLS على الجداول المالية الأساسية، حماية من Double Submission، وتقسيم صفحات التقارير (Pagination). **التصنيف الحالي:** نظام محلي قوي يتجه نحو ERP احترافي، **وليس بعد** ERP بمستوى عالمي دون معالجة الثغرات المذكورة.

---

# أولاً: التقييم المحاسبي (Accounting Integrity)

## 1.1 هل General Ledger هو المصدر الوحيد للحقيقة؟

**التقييم: نعم في التقارير المحاسبية الرسمية، لا في لوحة التحكم.**

- **التقارير المعتمدة:** Balance Sheet، Income Statement، Trial Balance، Cash Flow، General Ledger، Account Statement، Simple Report — **كلها** تعتمد على `journal_entries` → `journal_entry_lines` فقط (مُوثق في `docs/GENERAL_LEDGER_ARCHITECTURE.md` وملفات التقارير).
- **لوحة التحكم (Dashboard):** تقرأ من جداول تشغيلية مباشرة:
  - المبيعات والإيرادات من `invoices` (total_amount, paid_amount, status).
  - الذمم المدينة من `invoices` (مجموع total - paid).
  - الذمم الدائنة من `bills`.
  - COGS من `cogs_transactions` (مع fallback إلى `products.cost_price` في حال غياب سجلات COGS).
  - المصروفات من `journal_entry_lines` مع استثناء COGS.
- **النتيجة:** يمكن أن يعرض الـ Dashboard أرقاماً **مختلفة** عن P&L لو حصل تخلف بين حالة الفواتير/المدفوعات والقيود المرحّلة (مثلاً قيد تأخر أو خطأ في الربط).

**التوصية:** إما جعل Dashboard يقرأ الإيرادات/المصروفات/الذمم من تجميعات GL (أو من views موحدة مبنية على GL)، أو عرض تحذير واضح أن "أرقام لوحة التحكم تشغيلية وليست بديلاً عن التقارير المحاسبية".

---

## 1.2 هل جميع العمليات تنشئ قيود مزدوجة صحيحة؟

**التقييم: نعم في المسارات المُنفذة عبر الـ RPC والـ Engine؛ لا يوجد ضمان قاعدة بيانات لتوازن القيد.**

- ترحيل الفاتورة: قيد إيراد + قيد COGS (مدين/دائن متوازن) عبر `post_accounting_event` (ذرية).
- المدفوعات (عميل/مورد): قيود من `accrual-accounting-engine` أو RPC.
- الرواتب: قيد من حساب مصروف 6110 / حساب صرف (مدين = دائن).
- العمولات والسلف: دوال SQL تنشئ قيوداً مزدوجة (commission migrations).
- توزيعات الأرباح والسحوبات: `equity-transaction-service` ينشئ قيوداً.
- **لا يوجد** في قاعدة البيانات:
  - Constraint يفرض أن مجموع `debit_amount` = مجموع `credit_amount` لكل `journal_entry_id`.
  - Trigger لمنع حفظ قيد غير متوازن.
- التحقق من التوازن يتم في طبقة التطبيق (مثلاً عند إنشاء قيد يدوي) وفي API `accounting-validation` (Trial Balance). أي مسار يدرج سطور قيد مباشرة دون التحقق قد ينتج قيداً غير متوازن.

**التوصية:** إضافة trigger على `journal_entry_lines` (بعد INSERT/UPDATE/DELETE) يتحقق لكل `journal_entry_id` أن مجموع المدين = مجموع الدائن، ويرفض غير المتوازن.

---

## 1.3 هل COGS يعمل في كل الحالات (بيع – مرتجع – إلغاء)؟

**التقييم: البيع والمرتجع مغطيان؛ الإلغاء غير مكتمل.**

- **البيع:** عند الترحيل يتم استهلاك FIFO وإنشاء `cogs_transactions` وقيد COGS (مدين تكلفة، دائن مخزون) — يعمل.
- **مرتجع المبيعات:** `lib/sales-returns.ts` يعكس FIFO ويستدعي `prepareReverseCOGSTransaction` / `getCOGSByInvoice` وإنشاء حركات عكسية — مغطى.
- **مرتجع المشتريات:** `lib/purchase-return-fifo-reversal.ts` يعكس استهلاك FIFO وينشئ COGS reversal — مغطى.
- **إلغاء الفاتورة (cancelled):**
  - التوثيق وـ `accounting-validation` يتوقع أن الفواتير الملغاة **لا** يكون لها قيود إيراد مرحّلة (الاختبار: cancelledWithJournals === 0).
  - لم يُعثر في الكود على مسار موحد يلغي الفاتورة **ويقوم تلقائياً** بعكس/حذف قيود الإيراد والـ COGS واستعادة المخزون. وجود فواتير ملغاة لها قيود مرحّلة يُعتبر فشل في التحقق ويُبلغ عنه كـ warning.
- **النتيجة:** سيناريو "إلغاء فاتورة بعد الترحيل" غير مكتمل من ناحية محاسبية ومخزنية في التطبيق الحالي؛ الاعتماد على منع الترحيل للفواتير الملغاة أو معالجة إلغاء مخصصة.

**التوصية:** تعريف workflow واضح لإلغاء الفاتورة (بعد الترحيل): عكس قيد الإيراد، عكس قيد COGS، عكس حركات FIFO والمخزون، وتحديث الحالة — كل ذلك ذرياً إن أمكن.

---

## 1.4 هل المخزون متطابق دائماً بين FIFO و GL؟

**التقييم: مُصمم أن يتطابقا؛ التحقق موجود؛ قد يحدث تخلف في حال أخطاء أو مسارات جانبية.**

- التصميم: حركات المخزون وـ COGS تُنشأ معاً في نفس الـ RPC `post_accounting_event` (ذرية).
- FIFO يُحدّث `fifo_cost_lots` و`fifo_lot_consumptions` و`cogs_transactions`؛ قيد COGS يحرك حسابات المخزون والتكلفة في GL.
- API `accounting-validation` يضم اختبار "Inventory GL Balance = FIFO Engine Valuation" (مقارنة رصيد حسابات المخزون من GL مع مجموع قيمة FIFO) مع هامش 0.5%.
- إذا وُجدت عمليات تُغيّر المخزون أو القيود خارج هذا المسار (إصلاحات يدوية، استيراد، إلغاء غير معكوس)، يمكن أن يحدث تخلف.

**التوصية:** الإبقاء على اختبار التحقق وتشغيله دورياً؛ توثيق أي مسار يعدّل المخزون أو GL يدوياً وضمان أن يكون له "مقابل" في الطرف الآخر أو أن يُسجّل في تقرير استثناءات.

---

## 1.5 هل المرتجعات والخصومات تؤثر فعلياً على P&L؟

**نعم.** مرتجعات المبيعات تنشئ قيوداً محاسبية (إيراد سالب أو مصروف/استرداد) وتُسجّل في الـ GL؛ مرتجعات المشتريات تنشئ قيوداً (موردون، مخزون، COGS reversal). الخصومات على الفواتير/الفورمات تُحسب في المبالغ قبل إنشاء قيد الإيراد، فتظهر في الإيراد الصافي في GL. طالما التقارير تُبنى من GL، المرتجعات والخصومات مؤثرة في P&L.

---

## 1.6 هل الرواتب، العمولات، السلف، توزيعات الأرباح مسجلة محاسبياً؟

**نعم.**  
- **الرواتب:** API صرف المرتبات ينشئ `journal_entries` + `journal_entry_lines` (مصروف 6110 / حساب الصرف).  
- **العمولات:** دوال في migrations (مثل post_commission_payment، تسجيل الاستحقاق) تنشئ قيوداً وربطاً بـ `journal_entries`.  
- **السلف (advances):** جدول ودوال `commission_advance_payments` مع قيود محاسبية.  
- **توزيعات الأرباح والسحوبات:** `equity-transaction-service` ووظائف المساهمين تنشئ قيوداً (أرباح محتجزة، dividends payable، drawings، إلخ).

---

## 1.7 هل يوجد أي عملية تشغيلية لا تنشئ قيد محاسبي؟

**محتمل في حالات هامشية:**  
- لو وُجدت "مصروفات" أو مبالغ تُسجّل فقط في جداول تشغيلية دون المرور بـ `accrual-accounting-engine` أو RPC القيود، فلن تظهر في GL. مراجعة الـ codebase أظهرت أن المسارات الرئيسية (فواتير، مدفوعات، مصروفات، إهلاك، مرتجعات، رواتب، عمولات، حقوق ملكية) تنشئ قيوداً.  
- أي ميزة جديدة (مثلاً "مكافآت" أو "خصم نقدي" في نقطة بيع) يجب أن تُصمم لتمر عبر GL من اليوم الأول.

---

## 1.8 هل الميزانية العمومية متزنة دائماً؟

**نعم من ناحية المنطق:** Balance Sheet وTrial Balance يُحسبان من نفس المصدر (journal_entry_lines للقيود المرحّلة)، والمعادلة أصول = التزامات + حقوق ملكية مُحققة رياضياً من مجموع الأرصدة حسب الطبيعة.  
**لكن:** إذا وُجد قيد غير متوازن (بسبب خطأ تطبيق أو تدخل مباشر)، فستختل المعادلة. API `balance-sheet-audit` يفحص التوازن ويُظهر تحذيرات؛ لا يوجد منع عند المصدر (DB constraint) كما ذُكر أعلاه.

---

## 1.9 هل توجد سيناريوهات يمكن أن تكسر التوازن؟

**نعم:**  
1. **قيد غير متوازن:** إدراج أو تعديل سطور قيد يدوياً (أو عبر API) دون التحقق من مجموع مدين = مجموع دائن.  
2. **قيد مكرر لنفس المرجع:** الـ trigger الذي يمنع التكرار معطّل في `scripts/600_journal_entry_governance.sql` (تعليق على `CREATE TRIGGER trg_prevent_duplicate_journal_entry`)، ما يسمح نظرياً بقيود مكررة وقد يضاعف الإيراد أو المصروف.  
3. **فواتير ملغاة بقيود مرحّلة:** يرفع الإيراد المُبلّغ عنه ويخالف P&L الصحيح.  
4. **حذف أو تعديل قيد مرحّل:** مُمنوع بتريجر `prevent_posted_journal_modification` — جيد. لكن أي ثغرة تتجاوز التريجر (مثلاً وصول مباشر للـ DB) تكسر التوازن.

**التوصية:** تفعيل trigger منع القيود المكررة بعد التأكد من توافق المرجع (reference_type/reference_id) مع كل العمليات؛ وإضافة تحقق توازن القيد عند الحفظ (تطبيق و/أو trigger).

---

# ثانياً: التقارير والتحليلات

## 2.1 هل جميع التقارير تعتمد على GL؟

**لا.**  
- **تعتمد على GL بالكامل:** Balance Sheet، Income Statement، Trial Balance، Cash Flow، General Ledger، Account Statement، Simple Report (مع ملاحظة أن Simple Report يذكر استخدام bills للمشتريات "للتبسيط" في جزء من المنطق).  
- **لا تعتمد على GL بالكامل:** Dashboard (المبيعات، الذمم، أعداد الفواتير من `invoices`/`bills`، والمخزون من `inventory_transactions` + `fifo_cost_lots`).  
راجع أيضاً `docs/REPORTS_REVIEW_STATUS.md`.

---

## 2.2 هل Dashboard يمكن أن يعرض أرقاماً مختلفة عن P&L؟

**نعم.** لأن Dashboard يجمع من جداول تشغيلية (invoices, bills) بينما P&L من GL. أي تأخر أو خطأ في ترحيل القيود، أو فواتير "sent" لم يُنشأ لها قيد بعد، يسبب فرقاً.

---

## 2.3 هل يوجد جمع مباشر من جداول تشغيلية؟

**نعم.** Dashboard (كما في `app/api/dashboard-stats/route.ts`): invoices، bills، journal_entry_lines (للمصروفات مع استثناء COGS)، inventory_transactions، fifo_cost_lots، products. هذا مقصود لأداء و"لحظية" الأرقام التشغيلية، لكنه يخلق مصدرين للحقيقة.

---

## 2.4 هل Validation Layer كافية؟

**جيدة جداً.**  
- `app/api/accounting-validation/route.ts` يقدم مجموعة اختبارات: Trial Balance، توازن الميزانية، قيود الفواتير المرحّلة، COGS للفواتير، مرتجعات المبيعات، الفواتير الملغاة، ومقارنة مخزون GL مع FIFO.  
- يُمكّن من اكتشاف التضاربات والقيود غير المتوازنة. لا يمنع حدوث الخطأ من المصدر؛ يكتشفه بعد الوقوع.

---

## 2.5 هل النظام يمنع الإقفال عند وجود أخطاء؟

**لم يُعثر على ربط صريح:** لا يوجد في الكود ما يشير إلى أن "إقفال الفترة" (Period Closing) يرفض التنفيذ إذا فشل أحد اختبارات accounting-validation. إقفال الفترة يُنفّذ عبر API/وظيفة مستقلة. التوصية: جعل إقفال الفترة يستدعي نفس مجموعة التحققات (أو subset حرج) ويمنع الإقفال إذا فشل اختبار حرج (مثلاً Trial Balance غير متوازن).

---

# ثالثاً: المعمارية التقنية (Architecture Review)

## 3.1 هل المشروع Modular؟

**جزئياً.**  
- توجد طبقات واضحة: `lib` (ledger، accrual-accounting-engine، fifo-engine، cogs-transactions، accounting-transaction-service، period-closing، accounting-period-lock، sales-returns، purchase-return-fifo-reversal، equity، إلخ)، و`app/api` للـ routes، و`components`.  
- كثير من الصفحات الكبيرة (مثل `app/invoices/page.tsx`) تجمع واجهة ومنطق واستدعاءات في ملف واحد، ما يقلل الـ modularity على مستوى الواجهة.

---

## 3.2 هل يوجد Coupling مفرط بين الواجهة والمنطق؟

**نعم في أماكن.**  
- صفحات مثل الفواتير والمدفوعات ومرتجعات المشتريات تحتوي على منطق ترحيل واستدعاء RPC وفحص period lock داخل الـ component. نقل هذا المنطق إلى services أو server actions يقلل الاقتران ويُسهّل الاختبار وإعادة الاستخدام.

---

## 3.3 هل يوجد تكرار منطق في أكثر من مكان؟

**محتمل.**  
- فحص period lock مكرر في عدة صفحات (نفس استيراد ودالة `assertPeriodNotLocked`).  
- تجميع بيانات المبيعات/المشتريات من invoices/bills يظهر في Dashboard وفي أماكن أخرى.  
- توحيد "مصدر أرقام المبيعات/الذمم" في طبقة واحدة (مثلاً من GL أو من service موحد) يقلل التكرار والتناقض.

---

## 3.4 هل APIs مؤمنة بالكامل؟

**جزئياً.**  
- كثير من الـ APIs تستخدم `secureApiRequest` (مصادقة، شركة، صلاحيات حسب resource/action).  
- بعض الـ APIs تستخدم `api-security` (مثلاً balance-sheet-audit، payroll) وليس بالضرورة نفس التوقيع (مثلاً allowRoles).  
- لا يوجد حماية موحدة من Double Submission (idempotency keys) على المسارات المالية الحرجة.

---

## 3.5 هل يوجد Race Conditions محتملة؟

**ممكن في حالات نادرة.**  
- الترحيل الذري عبر RPC يقلل احتمال "نصف ترحيل".  
- لو تم استدعاء ترحيل نفس الفاتورة مرتين بالتوازي، قد يُنشأ قيدان إيراد (إلا إذا كان الـ RPC أو التطبيق يتحقق من وجود قيد سابق؛ في accounting-transaction-service يُتحقق من existingRevenue).  
- trigger منع القيود المكررة معطّل، لذا على مستوى DB لا يوجد منع.  
- العمليات التي لا تمر بـ RPC (مثل بعض تحديثات الحالة أو إدراج قيد من API منفصل) قد تتنافس مع واجهة المستخدم.

**التوصية:** تفعيل حماية التكرار حيث يلزم، واستخدام قفل أو تحقق "وجود قيد لهذا المرجع" داخل نفس الـ transaction.

---

## 3.6 هل العمليات المالية ذرية (Atomic Transactions)?

**نعم للمسارات الرئيسية.**  
- ترحيل الفاتورة: `post_accounting_event` (RPC) يدرج inventory، fifo consumptions، cogs، journal entries، وتحديث حالة المصدر في معاملة واحدة.  
- مرتجعات المشتريات والمدفوعات لها مسارات ذرية مماثلة أو استخدام نفس الـ RPC.  
- صرف الرواتب في API يُدرج journal header ثم lines في طلبات منفصلة؛ لو فشل الثاني يبقى قيد بلا سطور (خطر على التوازن). **التوصية:** دمج إدراج القيد وسطوره في RPC واحد أو استخدام transaction على مستوى التطبيق إن أمكن.

---

# رابعاً: الأمان (Security Review)

## 4.1 هل RLS مطبق بشكل صحيح؟

**جزئياً.**  
- RLS مُفعّل على جداول مثل: company_ai_settings، page_guides، fiscal_year_closings، purchase_return_warehouse_allocations، commission_advance_payments، credit_notes، commission_runs، audit_logs (مع منع UPDATE)، attendance_records، employees، payroll_runs، payroll_items، payroll_ledger، commission_plans، employee_commissions، commission_ledger، shareholders، profit_distributions، dividend_payments، shareholder_drawings، asset_transactions، third_party_inventory، expenses (سياسة UPDATE).  
- **لم يُعثر في الـ migrations المقدمة على تفعيل RLS لـ journal_entries، journal_entry_lines، invoices، bills، payments.** إن كان الوصول يتم عبر service role فقط من الخادم، فالعزل يعتمد على طبقة التطبيق وليس على RLS. للمستوى Enterprise يُفضّل تفعيل RLS على الجداول المالية بحيث لا يرى المستخدم إلا بيانات شركته (وفق company_id وربما branch).

---

## 4.2 هل يمكن تجاوز صلاحيات المستخدم؟

- الصلاحيات تُفحص في `secureApiRequest` (company membership، requirePermission، allowedRoles).  
- إن كانت الـ APIs تستدعي Supabase بـ service role من الخادم، فالمستخدم لا يتجاوز صلاحياته عبر العميل إلا إذا استطاع استدعاء API بدون مصادقة أو بصلاحية أعلى بسبب خطأ في التهيئة.  
- RLS غير المطبق على الجداول الحساسة يعني أن أي استعلام مباشر إلى DB (إن وُجد) قد يتجاوز حدود الشركة لو لم يُفلتر بـ company_id في الاستعلام نفسه.

**التوصية:** تفعيل RLS لـ journal_entries، journal_entry_lines، invoices، bills، payments، مع سياسات مرتبطة بـ company_id (وربما branch للفروع)، والاعتماد على نفس المعايير في الـ APIs.

---

## 4.3 هل توجد ثغرات في APIs؟

- لم يُراجع تفصيلاً كل endpoint لـ SQL injection أو parameter manipulation.  
- استخدام Supabase client مع معاملات مُربوطة يقلل مخاطر الـ injection.  
- عدم وجود rate limiting أو idempotency على المسارات المالية يفتح احتمال إساءة استخدام (تكرار طلبات الدفع أو الترحيل).

---

## 4.4 هل يوجد حماية من Double Submission؟

**لا بشكل منهجي.**  
- لا توجد idempotency keys أو أرقام عملية فريدة في طلبات الترحيل/الدفع في الـ codebase المُراجع.  
- بعض الدوال (مثل إشعارات أو commission) تذكر "idempotent" في التعليقات أو الاختبارات، لكن ليست مقياساً موحداً لجميع الـ APIs المالية.  
**التوصية:** إدخال Idempotency-Key (أو operation_id) للـ POST المالية ورفض الطلبات المكررة خلال نافذة زمنية.

---

## 4.5 هل يوجد Audit Trail كامل؟

**جيد نسبياً.**  
- جدول `audit_logs` مع سياسة منع UPDATE (immutability).  
- Triggers على جداول حرجة (sales_orders، purchase_returns، customer_debit_notes، inventory_write_offs، company_members، company_role_permissions، fixed_assets، asset_transactions، accounting_periods، payroll_runs).  
- **لا توجد triggers مراجعة على journal_entries و journal_entry_lines** في الملفات المُراجعة.  
- دوال مثل صرف الرواتب والعمولات تسجّل في audit_logs يدوياً.  
**التوصية:** إضافة triggers مراجعة على journal_entries و journal_entry_lines (وإن أمكن payments، invoices status changes) لضمان أثر كامل لأي تغيير مالي.

---

# خامساً: الأداء (Performance & Scalability)

## 5.1 هل النظام يتحمل 10,000 فاتورة/شهر، 1,000 موظف، ملايين قيود GL؟

**غير مؤكد دون اختبار تحميل.**  
- **General Ledger API:** يجلب كل السطور في النطاق الزمني دون pagination؛ مع ملايين القيود قد يكون الاستعلام والذاكرة ثقيلين.  
- **Trial Balance / Income Statement:** تجمع كل القيود المرحّلة للشركة في النطاق؛ نفس الملاحظة.  
- **Dashboard:** يجلب كل الفواتير والـ bills في النطاق ثم يحسب في الذاكرة؛ مع 10k+ فاتورة قد يبطئ.  
- **الفهارس:** وُجدت فهارس مثل `idx_inventory_transactions_created_at`؛ لم يُراجع كل الجداول الكبيرة (journal_entry_lines، journal_entries، invoice_items، إلخ) للتأكد من فهارس مناسبة لـ company_id + entry_date و reference_type + reference_id.

**التوصية:**  
- إضافة pagination (limit/offset أو cursor) لـ General Ledger وتقارير القيود الكبيرة.  
- مراجعة فهارس (company_id, entry_date)، (company_id, status, reference_type, reference_id) لـ journal_entries و journal_entry_lines.  
- تشغيل اختبارات تحميل لـ 10k فاتورة وشهر، وعدد كبير من قيود GL.

---

## 5.2 هل يوجد فهارس كافية؟

- وُجدت فهارس على inventory_transactions، وبعض الجداول الأخرى.  
- لم يُجرَ فهرس شامل لجميع الاستعلامات الثقيلة في التقارير والـ APIs. يُنصح بمراجعة استعلامات GL وTrial Balance وIncome Statement وإضافة الفهارس اللازمة.

---

## 5.3 هل يوجد استعلامات ثقيلة غير محسنة؟

- استعلامات تجمع كل القيود في نطاق زمني دون حد أعلى للحجم.  
- بعض التقارير تعيد كل السطور ثم تُعالج في التطبيق (مثلاً تجميع حسب حساب). تحريك التجميع إلى DB (GROUP BY) قد يقلل حجم البيانات المرتجعة ويحسّن الأداء.

---

## 5.4 هل يوجد Pagination في التقارير الكبيرة؟

**لا في General Ledger وعدد من التقارير.** الـ route لا يطبق limit ولا offset؛ يُرجع كل الحسابات وكل الحركات في الفترة. للمستوى Enterprise يُفضّل pagination أو تصدير مجزأ.

---

# سادساً: تجربة المستخدم (UX & Enterprise Readiness)

## 6.1 هل الواجهة مناسبة لشركات كبيرة؟

- الواجهة تدعم العربية والإنجليزية، وأدوار وصلاحيات.  
- حجم بعض الصفحات (مثل invoices) كبير جداً؛ قد يؤثر على الصيانة والأداء في المتصفح.  
- لا يوجد دليل موحد "للشركات الكبيرة" (مثلاً onboarding، أدوار متعددة المستويات، تفويض صلاحيات تفصيلي).

---

## 6.2 هل يوجد Workflow واضح؟

- توجد حالات للفواتير (draft → sent → paid) والموافقات (مثل write-off، بعض المسارات).  
- لا يوجد BPM موحّد أو محرك سير عمل مرئي لجميع العمليات (موافقات، تصعيد، إلخ).

---

## 6.3 هل يوجد Period Lock حقيقي؟

**نعم.**  
- `accounting_periods` مع `is_locked` و status (open/closed/locked).  
- `assertPeriodNotLocked` يُستدعى في: journal-entries/new، invoices [id] (تغيير حالة)، payments، purchase-returns/new، banking [id]، وضمن `accrual-accounting-engine` (createInvoiceRevenueJournal، saveJournalEntry).  
- **لا يُستدعى في:** API صرف الرواتب، API اعتماد الإهلاك (write-offs/approve)، وربما مسارات API أخرى للترحيل أو القيود. أي استدعاء مباشر لـ API دون المرور بالصفحة يتجاوز فحص الـ period lock الحالي.

**التوصية:** استدعاء `assertPeriodNotLocked` في **جميع** الـ API routes التي تنشئ أو تعدّل قيوداً أو تغيّر حالة مالية (payroll pay، write-off approve، أي ترحيل من API، إلخ).

---

## 6.4 هل يوجد Approval System؟

- موافقات موجودة لبعض العمليات (مثل اعتماد الإهلاك، وأدوار owner/admin).  
- لا يوجد نظام موافقات موحّد (مستويات، تفويض، سجل موافقات) لجميع المعاملات الحرجة.

---

## 6.5 هل يوجد Role Hierarchy احترافي؟

- توجد أدوار (owner، admin، manager، accountant، إلخ) وصلاحيات (resource/action) في `secureApiRequest` و`company_role_permissions`.  
- لم يُراجع عمق التسلسل (وراثة صلاحيات، قواعد لكل وحدة تنظيمية). التقييم: أساس موجود؛ يحتاج توسيعاً ليكون "احترافياً" بالكامل (تسلسل هرمي، تفويض، حدود فرع/مركز تكلفة).

---

# سابعاً: الذكاء الاصطناعي والمساعد

## 7.1 هل AI Assistant فعلاً Context-aware؟

- المساعد يعتمد على `page_guides` (محتوى ثابت حسب الصفحة) و`lib/page-guides.ts` (تعيين path → page_key).  
- المحتوى يُجلب حسب الصفحة الحالية ويُعرض في الـ Guide Panel (خطوات، نصائح، نمط محاسبي إن وُجد).  
- "Context" = الصفحة الحالية وليس بيانات المستخدم أو الأرقام الفعلية؛ أي لا يقرأ من GL أو الفواتير مباشرة.  
- **النتيجة:** context-aware بمعنى "الصفحة الحالية"، وليس بمعنى تحليل البيانات المالية الفعلية.

---

## 7.2 هل هو آمن؟

- الإعدادات في `company_ai_settings` مع RLS.  
- المحتوى من `page_guides` (قراءة)؛ لا ينفذ عمليات مالية.  
- إن لم يُضف في المستقبل استدعاءات لـ APIs حساسة أو تنفيذ أوامر، يبقى التأثير الأمني محدوداً.

---

## 7.3 هل لا يؤثر على الأداء؟

- تحميل الدليل كسول (عند فتح اللوحة).  
- الإعدادات مخزنة في localStorage بوقت انتهاء.  
- لا يُتوقع تأثير كبير على الأداء ما دام لا يجرى استعلامات ثقيلة عند كل تحميل صفحة.

---

## 7.4 هل قابل للتوسع؟

- إضافة صفحات جديدة يتطلب إضافة page_key وتعيين في PAGE_KEY_MAP ومحتوى في DB.  
- توسيع "الذكاء" (مثلاً اقتراح قيود أو تفسير أرقام) سيتطلب تكامل مع نموذج لغة أو بيانات مالية مع ضوابط أمان وصول.

---

# ثامناً: اختبارات التحمل وسيناريوهات الفشل

## 8.1 ماذا يحدث عند فشل Transaction؟

- الـ RPC `post_accounting_event` يعمل في معاملة واحدة؛ عند فشل أي خطوة يتم rollback.  
- في مسارات لا تستخدم RPC (مثلاً إدراج قيد ثم سطور في طلبات منفصلة)، فشل الطلب الثاني يترك قيداً بلا سطور أو بيانات غير متسقة. **التوصية:** جعل كل عمليات "قيد + سطور" ذرية (داخل RPC أو transaction واحد).

---

## 8.2 ماذا يحدث عند انقطاع الاتصال أثناء الترحيل؟

- من جهة الخادم: إما اكتمال الـ RPC أو rollback.  
- من جهة العميل: قد يظهر خطأ للمستخدم دون معرفة إن كان الترحيل تم أم لا. إعادة المحاولة قد تؤدي لطلب مكرر (ولا توجد idempotency). **التوصية:** رسائل خطأ واضحة + "تحقق من حالة الفاتورة قبل إعادة المحاولة"، وإدخال idempotency لتجنب التكرار.

---

## 8.3 ماذا يحدث عند محاولة تنفيذ عمليتين متزامنتين؟

- التحقق من "وجود قيد إيراد سابق" في ترحيل الفاتورة يقلل احتمال قيدين لنفس الفاتورة من نفس المسار.  
- trigger منع التكرار معطّل؛ وبدون قفل (lock) أو شرط "insert if not exists" في نفس الـ transaction يبقى احتمال نادر لقيود مكررة. **التوصية:** تفعيل الحماية من التكرار و/أو استخدام قفل على المرجع (reference_type + reference_id) داخل الـ RPC.

---

## 8.4 هل يوجد Retry-safe logic؟

- لا توجد idempotency keys؛ إعادة المحاولة قد تُنشئ قيداً أو دفعة مكررة.  
- دوال مثل ترحيل الفاتورة تتحقق من وجود قيد قبل الإنشاء، ما يحد من التكرار في هذا المسار فقط. **التوصية:** تصميم المسارات المالية ليكون إعادة الطلب بنفس المفتاح آمنة (idempotent).

---

# تاسعاً: التقييم النهائي

## 9.1 نسبة تقييم لكل محور (من 10)

| المحور | النسبة | ملاحظة مختصرة |
|--------|--------|----------------|
| التقييم المحاسبي (سلامة GL، قيود مزدوجة، COGS، مرتجعات، راتب/عمولة/سلف/أرباح) | **7.5/10** | أساس قوي؛ غياب constraint توازن القيد وتريجر التكرار، وسيناريو إلغاء الفاتورة غير مكتمل |
| التقارير والتحليلات | **7/10** | التقارير الرسمية من GL ممتازة؛ Dashboard من جداول تشغيلية؛ عدم ربط الإقفال بتحققات التحقق |
| المعمارية التقنية | **6.5/10** | ذرية جيدة في RPC؛ اقتران واجهة/منطق وتكرار؛ عدم حماية مزدوج الإرسال وعدم تفعيل كل الحوكمة في DB |
| الأمان | **6/10** | صلاحيات API جيدة؛ RLS ناقص على الجداول المالية؛ لا idempotency؛ audit على جداول كثيرة لكن ليس على journal_entries/lines |
| الأداء وقابلية التوسع | **5.5/10** | عدم pagination في GL وتقارير كبيرة؛ فهارس غير مضمونة لكل السيناريوهات؛ لم يُختبر تحميل 10k/1k/ملايين |
| UX وجاهزية Enterprise | **6/10** | Period lock حقيقي لكن غير مطبق على كل المسارات؛ لا workflow موحّد؛ أساس أدوار موجود |
| المساعد الذكي | **6.5/10** | Context-aware حسب الصفحة؛ آمن ولا يؤثر أداء؛ قابل للتوسع بالمحتوى |
| سيناريوهات الفشل وRetry | **5.5/10** | RPC ذري جيد؛ لا idempotency؛ إعادة المحاولة قد تُكرر عمليات؛ بعض المسارات غير ذرية بالكامل |

---

## 9.2 التقييم الإجمالي للمشروع

**تقدير إجمالي: 6.3/10** — مشروع محاسبي جيد التصميم في القلب، مع تطبيق صارم لمصدر الحقيقة (GL) في التقارير الرسمية وعمليات ذرية للترحيل، لكن مع فجوات في الاتساق (Dashboard vs P&L)، الحوكمة عند المصدر (DB)، الأمان (RLS، idempotency)، والأداء (pagination، فهارس، اختبار تحميل).

---

## 9.3 التصنيف

- **نظام محلي جيد:** **نعم** — يصلح لشركة صغيرة/متوسطة مع مراجعة دورية (accounting-validation) ووعي بعدم الاعتماد على Dashboard كبديل عن P&L.  
- **ERP احترافي:** **قريب** — يلزم سد الثغرات الحرجة (Period Lock على كل المسارات، توحيد مصدر Dashboard أو تحذير واضح، تفعيل حماية التكرار وتوازن القيود، RLS على الجداول المالية، pagination للتقارير الكبيرة).  
- **ERP بمستوى عالمي:** **لا** — يلزم بالإضافة لما سبق: اختبارات تحميل ومعالجة فشل متقدمة، idempotency، audit على كل الجداول المالية، وتحسينات معمارية (فصل منطق الواجهة، تقليل التكرار، توثيق واختبارات آلية أوسع).

---

## 9.4 قائمة الثغرات الحرجة

1. **Period Lock غير مطبق على كل المسارات المالية:** صرف الرواتب، اعتماد الإهلاك، وأي ترحيل/قيد يتم من API دون استدعاء `assertPeriodNotLocked`.  
2. **Dashboard يعتمد على جداول تشغيلية:** يمكن أن تختلف أرقامه عن P&L؛ لا تحذير واضح للمستخدم.  
3. **عدم وجود منع عند المصدر لقيود غير متوازنة:** لا constraint ولا trigger يفرض مجموع مدين = مجموع دائن لكل قيد.  
4. **تريجر منع القيود المكررة معطّل:** احتمال قيود مكررة لنفس المرجع.  
5. **غياب RLS على journal_entries و journal_entry_lines و invoices و bills و payments:** العزل يعتمد على التطبيق فقط.  
6. **عدم وجود حماية من Double Submission (idempotency)** على المسارات المالية.  
7. **إلغاء الفاتورة بعد الترحيل:** لا workflow موحّد لعكس الإيراد والـ COGS والمخزون.  
8. **صرف الرواتب (وبعض المسارات الأخرى) غير ذري بالكامل:** إدراج قيد ثم سطور في طلبات منفصلة.  
9. **عدم Pagination في General Ledger وتقارير كبيرة:** خطر على الأداء مع حجم بيانات كبير.  
10. **عدم وجود ربط بين إقفال الفترة ونتائج accounting-validation:** لا منع تلقائي للإقفال عند فشل تحقق حرج.

---

## 9.5 قائمة التحسينات للوصول إلى مستوى Enterprise كامل

1. **محاسبة:**  
   - إضافة trigger أو constraint لتوازن كل قيد (مجموع مدين = مجموع دائن).  
   - تفعيل trigger منع القيود المكررة (مع مراعاة reference_type/reference_id).  
   - تعريف وتنفيذ workflow إلغاء فاتورة (عكس إيراد، COGS، مخزون) ذرياً.  
   - جعل إقفال الفترة يعتمد على تحققات accounting-validation ويمنع الإقفال عند فشل حرج.

2. **تقارير واتساق:**  
   - جعل Dashboard يقرأ من GL (أو views موحدة) للإيرادات/المصروفات/الذمم، أو إظهار تحذير بأن الأرقام "تشغيلية".  
   - إضافة pagination (أو تصدير مجزأ) لـ General Ledger وتقارير القيود الكبيرة.

3. **أمان:**  
   - تفعيل RLS على journal_entries، journal_entry_lines، invoices، bills، payments بسياسات مرتبطة بـ company_id (وربما branch).  
   - إدخال Idempotency-Key (أو operation_id) للـ POST المالية ورفض الطلبات المكررة.  
   - إضافة audit triggers على journal_entries و journal_entry_lines (وإن أمكن payments وتغييرات حالة الفواتير).

4. **Period Lock:**  
   - استدعاء `assertPeriodNotLocked` في **كل** API route ينشئ أو يعدّل قيوداً أو يغيّر حالة مالية (payroll pay، write-off approve، ترحيل، إلخ).

5. **ذرية وموثوقية:**  
   - جعل صرف الرواتب (وكل "قيد + سطور") ذرياً عبر RPC أو transaction واحد.  
   - توثيق وتنفيذ retry-safe (idempotent) للمسارات الحرجة.

6. **أداء:**  
   - مراجعة فهارس الجداول الكبيرة (journal_entries، journal_entry_lines، invoice_items، إلخ) وإضافة ما يلزم لـ company_id، entry_date، reference_type، reference_id.  
   - تشغيل اختبارات تحميل (10k فاتورة/شهر، 1k موظف، ملايين قيود) وضبط الاستعلامات والفهارس.

7. **معمارية:**  
   - فصل منطق الترحيل والتحقق من الصفحات إلى services/server actions.  
   - توحيد مصدر أرقام المبيعات/الذمم في طبقة واحدة.

---

**نهاية التقرير.**  
هذا التقييم مبني على مراجعة الكود والملفات والـ migrations المذكورة؛ أي تغيير لاحق في المشروع قد يغير بعض النتائج. يُوصى بإعادة المراجعة بعد تنفيذ التحسينات الحرجة.
